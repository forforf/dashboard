// Generated by CoffeeScript 1.3.3
(function() {
  "use strict";

  var AppCtrl, RepoCtrl, StatusGraph, d3DemoApp, makeChart, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  StatusGraph = root.StatusGraph;

  d3DemoApp = angular.module("d3DemoApp", []);

  makeChart = function(data) {
    var chart;
    chart = new StatusGraph(d3.select('#repos'), data);
    return chart.svg();
  };

  d3DemoApp.controller("RepoCtrl", RepoCtrl = function($scope, $http) {
    var repo;
    $scope.user = "forforf";
    repo = $scope.repo = {};
    repo.name = "Code Thoughts";
    repo.loc = "code_thoughts";
    $scope.getRepoData = function() {
      $scope.test = {
        repo_data: {
          uri: "https://github.com/" + $scope.user + "/" + $scope.repo.loc + "/wiki.atom",
          label: "Status"
        }
      };
      return $http({
        method: "GET",
        url: "http://localhost:3000/test",
        params: $scope.test.repo_data
      }).success(function(data) {
        $scope.repo.scorecard = data;
        makeChart(data);
        return $scope.error = "";
      }).error(function(data, status) {
        if (status === 404) {
          return $scope.error = "Wiki atom parser does not exist";
        } else {
          return $scope.error = "Error: " + status;
        }
      });
    };
    return $scope.getRepoData();
  });

  d3DemoApp.controller("AppCtrl", AppCtrl = function($scope, $http) {
    var humanReadableDate, reformatGithubResponse;
    $scope.user = "forforf";
    $scope.repo = "code_thoughts";
    humanReadableDate = function(d) {
      return d.getUTCMonth() + "/" + d.getUTCDate();
    };
    reformatGithubResponse = function(data) {
      var authorMap, date0, dateN, days, formattedData, i, j, uniqueAuthors;
      data.sort(function(a, b) {
        if (new Date(a.commit.author.date) > new Date(b.commit.author.date)) {
          return -1;
        } else {
          return 1;
        }
      });
      date0 = new Date(data[data.length - 1].commit.author.date);
      dateN = new Date(data[0].commit.author.date);
      days = Math.floor((dateN - date0) / 86400000) + 1;
      uniqueAuthors = [];
      authorMap = {};
      data.forEach(function(datum) {
        var name;
        name = datum.commit.author.name;
        if (uniqueAuthors.indexOf(name) === -1) {
          authorMap[name] = uniqueAuthors.length;
          return uniqueAuthors.push(name);
        }
      });
      formattedData = [];
      formattedData.length = uniqueAuthors.length;
      i = void 0;
      j = void 0;
      i = 0;
      while (i < formattedData.length) {
        formattedData[i] = [];
        formattedData[i].length = days;
        j = 0;
        while (j < formattedData[i].length) {
          formattedData[i][j] = {
            x: j,
            y: 0
          };
          j++;
        }
        i++;
      }
      data.forEach(function(datum) {
        var curDay, date;
        date = new Date(datum.commit.author.date);
        curDay = Math.floor((date - date0) / 86400000);
        formattedData[authorMap[datum.commit.author.name]][curDay].y += 1;
        return formattedData[0][curDay].date = humanReadableDate(date);
      });
      i = 0;
      while (i < uniqueAuthors.length) {
        formattedData[i][0].user = uniqueAuthors[i];
        i++;
      }
      return formattedData;
    };
    $scope.getCommitData = function() {
      $scope.test = {
        repo_data: {
          uri: "https://github.com/" + $scope.user + "/" + $scope.repo + "/wiki.atom",
          label: "Status"
        }
      };
      $http({
        method: "GET",
        url: "https://api.github.com/repos/" + $scope.user + "/" + $scope.repo + "/commits"
      }).success(function(data) {
        $scope.data = reformatGithubResponse(data);
        $scope.test.data = $scope.data;
        console.log($scope.test);
        return $scope.error = "";
      }).error(function(data, status) {
        if (status === 404) {
          return $scope.error = "That repository does not exist";
        } else {
          return $scope.error = "Error: " + status;
        }
      });
      return $http({
        method: "GET",
        url: "http://localhost:3000/test",
        params: $scope.test.repo_data
      }).success(function(data) {
        $scope.test.scorecard = data;
        console.log($scope.test);
        return $scope.error = "";
      }).error(function(data, status) {
        if (status === 404) {
          return $scope.error = "Wiki atom parser does not exist";
        } else {
          return $scope.error = "Error: " + status;
        }
      });
    };
    return $scope.getCommitData();
  });

  /*
  d3DemoApp.directive "ghVisualization", ->
    
    # constants
    margin = 20
    width = 960
    height = 500 - .5 - margin
    color = d3.interpolateRgb("#f77", "#77f")
    restrict: "E"
    terminal: true
    scope:
      val: "="
      grouped: "="
  
    link: (scope, element, attrs) ->
      
      # set up initial svg object
      vis = d3.select(element[0]).append("svg").attr("width", width).attr("height", height + margin + 100)
      scope.$watch "val", (newVal, oldVal) ->
        
        # clear the elements inside of the directive
        
        # if 'val' is undefined, exit
        
        # Based on: http://mbostock.github.com/d3/ex/stack.html
        # number of layers
        # number of samples per layer
        # or `my` not rescale
        
        # Layers for each color
        # =====================
        
        # Bars
        # ====
        
        # X-axis labels
        # =============
        
        # Chart Key
        # =========
        
        # Animate between grouped and stacked
        # ===================================
        transitionGroup = ->
          transitionEnd = ->
            d3.select(this).transition().duration(500).attr("y", (d) ->
              height - y2(d)
            ).attr "height", y2
          vis.selectAll("g.layer rect").transition().duration(500).delay((d, i) ->
            (i % m) * 10
          ).attr("x", (d, i) ->
            x x: .9 * ~~(i / m) / n
          ).attr("width", x(x: .9 / n)).each "end", transitionEnd
        transitionStack = ->
          transitionEnd = ->
            d3.select(this).transition().duration(500).attr("x", 0).attr "width", x(x: .9)
          vis.selectAll("g.layer rect").transition().duration(500).delay((d, i) ->
            (i % m) * 10
          ).attr("y", y1).attr("height", (d) ->
            y0(d) - y1(d)
          ).each "end", transitionEnd
        vis.selectAll("*").remove()
        return  unless newVal
        n = newVal.length
        m = newVal[0].length
        data = d3.layout.stack()(newVal)
        mx = m
        my = d3.max(data, (d) ->
          d3.max d, (d) ->
            d.y0 + d.y
  
        )
        mz = d3.max(data, (d) ->
          d3.max d, (d) ->
            d.y
  
        )
        x = (d) ->
          d.x * width / mx
  
        y0 = (d) ->
          height - d.y0 * height / my
  
        y1 = (d) ->
          height - (d.y + d.y0) * height / my
  
        y2 = (d) ->
          d.y * height / mz
  
        layers = vis.selectAll("g.layer").data(data).enter().append("g").style("fill", (d, i) ->
          color i / (n - 1)
        ).attr("class", "layer")
        bars = layers.selectAll("g.bar").data((d) ->
          d
        ).enter().append("g").attr("class", "bar").attr("transform", (d) ->
          "translate(" + x(d) + ",0)"
        )
        bars.append("rect").attr("width", x(x: .9)).attr("x", 0).attr("y", height).attr("height", 0).transition().delay((d, i) ->
          i * 10
        ).attr("y", y1).attr "height", (d) ->
          y0(d) - y1(d)
  
        labels = vis.selectAll("text.label").data(data[0]).enter().append("text").attr("class", "label").attr("x", x).attr("y", height + 6).attr("dx", x(x: .45)).attr("dy", ".71em").attr("text-anchor", "middle").text((d, i) ->
          d.date
        )
        keyText = vis.selectAll("text.key").data(data).enter().append("text").attr("class", "key").attr("y", (d, i) ->
          height + 42 + 30 * (i % 3)
        ).attr("x", (d, i) ->
          155 * Math.floor(i / 3) + 15
        ).attr("dx", x(x: .45)).attr("dy", ".71em").attr("text-anchor", "left").text((d, i) ->
          d[0].user
        )
        keySwatches = vis.selectAll("rect.swatch").data(data).enter().append("rect").attr("class", "swatch").attr("width", 20).attr("height", 20).style("fill", (d, i) ->
          color i / (n - 1)
        ).attr("y", (d, i) ->
          height + 36 + 30 * (i % 3)
        ).attr("x", (d, i) ->
          155 * Math.floor(i / 3)
        )
        
        # reset grouped state to false
        scope.grouped = false
        
        # setup a watch on 'grouped' to switch between views
        scope.$watch "grouped", (newVal, oldVal) ->
          
          # ignore first call which happens before we even have data from the Github API
          return  if newVal is oldVal
          if newVal
            transitionGroup()
          else
            transitionStack()
  */


}).call(this);
