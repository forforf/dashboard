// Generated by CoffeeScript 1.3.3
(function() {
  "use strict";

  var AppCtrl, RepoCtrl, d3DemoApp, interpolateColor, makeChart;

  interpolateColor = function(minColor, maxColor, maxDepth, depth) {
    var color, d2h, h2d, i, maxVal, minVal, nVal, val, _i;
    d2h = function(d) {
      return d.toString(16);
    };
    h2d = function(h) {
      return parseInt(h, 16);
    };
    if (depth === 0) {
      return minColor;
    }
    if (depth === maxDepth) {
      return maxColor;
    }
    color = "#";
    for (i = _i = 1; _i <= 6; i = _i += 2) {
      minVal = new Number(h2d(minColor.substr(i, 2)));
      maxVal = new Number(h2d(maxColor.substr(i, 2)));
      nVal = minVal + (maxVal - minVal) * (depth / maxDepth);
      val = d2h(Math.floor(nVal));
      while (val.length < 2) {
        val = "0" + val;
      }
      color += val;
    }
    return color;
  };

  d3DemoApp = angular.module("d3DemoApp", []);

  makeChart = function(data) {
    var bar_data, bar_height, cat_data, cat_name, chart, chart_width, gradient_defs, gradient_start_color, gradient_stop_color, gradients, i, iters, test, x_scaler, _i, _len;
    chart_width = document.getElementById('repos').offsetWidth;
    bar_height = 16;
    gradient_start_color = "#e0c0e0";
    gradient_stop_color = "#c0e0e0";
    console.log("Testing", test);
    x_scaler = d3.scale.linear().domain([0, 10]).range([0, chart_width]);
    bar_data = [];
    for (cat_name in data) {
      cat_data = data[cat_name];
      if (cat_data.score) {
        bar_data.push({
          name: cat_name,
          score: cat_data.score
        });
      }
    }
    test = d3.select('.test').style("background-color");
    console.log('test chart', test);
    console.log("Chart data", bar_data);
    chart = d3.select('#repos').append('svg:svg');
    gradient_defs = chart.append("svg:defs");
    iters = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    gradients = [];
    for (_i = 0, _len = iters.length; _i < _len; _i++) {
      i = iters[_i];
      console.log(i);
      gradients[i] = gradient_defs.append("svg:linearGradient").attr("id", "gradient-" + i).attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%").attr("spreadMethod", "pad");
      gradients[i].append("svg:stop").attr("offset", "0%").attr("stop-color", gradient_start_color).attr("stop-opacity", 1);
      gradients[i].append("svg:stop").attr("offset", "100%").attr("stop-opacity", 1).attr("stop-color", gradient_stop_color);
    }
    chart.attr("class", "chart").attr("height", bar_height * bar_data.length);
    chart.attr("width", chart_width);
    chart.selectAll("rect.repo-chart-bg").data(bar_data).enter().append("rect").attr("class", "bars").attr("y", function(d, i) {
      return i * bar_height;
    }).attr("width", function(d) {
      return x_scaler(d.score);
    }).attr("height", bar_height).style("fill", "url(#gradient-0)");
    return chart.selectAll("text").data(bar_data).enter().append("text").attr("x", 0).attr("y", function(d, i) {
      return 16 * i;
    }).attr("dy", 10).attr("text-anchor", "left").attr("style", "font-size: 12; font-family: Arial, sans-serif").attr("fill", "#2020DD").text(function(d) {
      return d.name;
    }).attr("transform", "translate(8,1)").attr("class", "labels");
  };

  d3DemoApp.controller("RepoCtrl", RepoCtrl = function($scope, $http) {
    var repo;
    $scope.user = "forforf";
    repo = $scope.repo = {};
    repo.name = "Code Thoughts";
    repo.loc = "code_thoughts";
    $scope.getRepoData = function() {
      $scope.test = {
        repo_data: {
          uri: "https://github.com/" + $scope.user + "/" + $scope.repo.loc + "/wiki.atom",
          label: "Status"
        }
      };
      return $http({
        method: "GET",
        url: "http://localhost:3000/test",
        params: $scope.test.repo_data
      }).success(function(data) {
        $scope.repo.scorecard = data;
        makeChart(data);
        return $scope.error = "";
      }).error(function(data, status) {
        if (status === 404) {
          return $scope.error = "Wiki atom parser does not exist";
        } else {
          return $scope.error = "Error: " + status;
        }
      });
    };
    return $scope.getRepoData();
  });

  d3DemoApp.controller("AppCtrl", AppCtrl = function($scope, $http) {
    var humanReadableDate, reformatGithubResponse;
    $scope.user = "forforf";
    $scope.repo = "code_thoughts";
    humanReadableDate = function(d) {
      return d.getUTCMonth() + "/" + d.getUTCDate();
    };
    reformatGithubResponse = function(data) {
      var authorMap, date0, dateN, days, formattedData, i, j, uniqueAuthors;
      data.sort(function(a, b) {
        if (new Date(a.commit.author.date) > new Date(b.commit.author.date)) {
          return -1;
        } else {
          return 1;
        }
      });
      date0 = new Date(data[data.length - 1].commit.author.date);
      dateN = new Date(data[0].commit.author.date);
      days = Math.floor((dateN - date0) / 86400000) + 1;
      uniqueAuthors = [];
      authorMap = {};
      data.forEach(function(datum) {
        var name;
        name = datum.commit.author.name;
        if (uniqueAuthors.indexOf(name) === -1) {
          authorMap[name] = uniqueAuthors.length;
          return uniqueAuthors.push(name);
        }
      });
      formattedData = [];
      formattedData.length = uniqueAuthors.length;
      i = void 0;
      j = void 0;
      i = 0;
      while (i < formattedData.length) {
        formattedData[i] = [];
        formattedData[i].length = days;
        j = 0;
        while (j < formattedData[i].length) {
          formattedData[i][j] = {
            x: j,
            y: 0
          };
          j++;
        }
        i++;
      }
      data.forEach(function(datum) {
        var curDay, date;
        date = new Date(datum.commit.author.date);
        curDay = Math.floor((date - date0) / 86400000);
        formattedData[authorMap[datum.commit.author.name]][curDay].y += 1;
        return formattedData[0][curDay].date = humanReadableDate(date);
      });
      i = 0;
      while (i < uniqueAuthors.length) {
        formattedData[i][0].user = uniqueAuthors[i];
        i++;
      }
      return formattedData;
    };
    $scope.getCommitData = function() {
      $scope.test = {
        repo_data: {
          uri: "https://github.com/" + $scope.user + "/" + $scope.repo + "/wiki.atom",
          label: "Status"
        }
      };
      $http({
        method: "GET",
        url: "https://api.github.com/repos/" + $scope.user + "/" + $scope.repo + "/commits"
      }).success(function(data) {
        $scope.data = reformatGithubResponse(data);
        $scope.test.data = $scope.data;
        console.log($scope.test);
        return $scope.error = "";
      }).error(function(data, status) {
        if (status === 404) {
          return $scope.error = "That repository does not exist";
        } else {
          return $scope.error = "Error: " + status;
        }
      });
      return $http({
        method: "GET",
        url: "http://localhost:3000/test",
        params: $scope.test.repo_data
      }).success(function(data) {
        $scope.test.scorecard = data;
        console.log($scope.test);
        return $scope.error = "";
      }).error(function(data, status) {
        if (status === 404) {
          return $scope.error = "Wiki atom parser does not exist";
        } else {
          return $scope.error = "Error: " + status;
        }
      });
    };
    return $scope.getCommitData();
  });

  d3DemoApp.directive("ghVisualization", function() {
    var color, height, margin, width;
    margin = 20;
    width = 960;
    height = 500 - .5 - margin;
    color = d3.interpolateRgb("#f77", "#77f");
    return {
      restrict: "E",
      terminal: true,
      scope: {
        val: "=",
        grouped: "="
      },
      link: function(scope, element, attrs) {
        var vis;
        vis = d3.select(element[0]).append("svg").attr("width", width).attr("height", height + margin + 100);
        return scope.$watch("val", function(newVal, oldVal) {
          var bars, data, keySwatches, keyText, labels, layers, m, mx, my, mz, n, transitionGroup, transitionStack, x, y0, y1, y2;
          transitionGroup = function() {
            var transitionEnd;
            transitionEnd = function() {
              return d3.select(this).transition().duration(500).attr("y", function(d) {
                return height - y2(d);
              }).attr("height", y2);
            };
            return vis.selectAll("g.layer rect").transition().duration(500).delay(function(d, i) {
              return (i % m) * 10;
            }).attr("x", function(d, i) {
              return x({
                x: .9 * ~~(i / m) / n
              });
            }).attr("width", x({
              x: .9 / n
            })).each("end", transitionEnd);
          };
          transitionStack = function() {
            var transitionEnd;
            transitionEnd = function() {
              return d3.select(this).transition().duration(500).attr("x", 0).attr("width", x({
                x: .9
              }));
            };
            return vis.selectAll("g.layer rect").transition().duration(500).delay(function(d, i) {
              return (i % m) * 10;
            }).attr("y", y1).attr("height", function(d) {
              return y0(d) - y1(d);
            }).each("end", transitionEnd);
          };
          vis.selectAll("*").remove();
          if (!newVal) {
            return;
          }
          n = newVal.length;
          m = newVal[0].length;
          data = d3.layout.stack()(newVal);
          mx = m;
          my = d3.max(data, function(d) {
            return d3.max(d, function(d) {
              return d.y0 + d.y;
            });
          });
          mz = d3.max(data, function(d) {
            return d3.max(d, function(d) {
              return d.y;
            });
          });
          x = function(d) {
            return d.x * width / mx;
          };
          y0 = function(d) {
            return height - d.y0 * height / my;
          };
          y1 = function(d) {
            return height - (d.y + d.y0) * height / my;
          };
          y2 = function(d) {
            return d.y * height / mz;
          };
          layers = vis.selectAll("g.layer").data(data).enter().append("g").style("fill", function(d, i) {
            return color(i / (n - 1));
          }).attr("class", "layer");
          bars = layers.selectAll("g.bar").data(function(d) {
            return d;
          }).enter().append("g").attr("class", "bar").attr("transform", function(d) {
            return "translate(" + x(d) + ",0)";
          });
          bars.append("rect").attr("width", x({
            x: .9
          })).attr("x", 0).attr("y", height).attr("height", 0).transition().delay(function(d, i) {
            return i * 10;
          }).attr("y", y1).attr("height", function(d) {
            return y0(d) - y1(d);
          });
          labels = vis.selectAll("text.label").data(data[0]).enter().append("text").attr("class", "label").attr("x", x).attr("y", height + 6).attr("dx", x({
            x: .45
          })).attr("dy", ".71em").attr("text-anchor", "middle").text(function(d, i) {
            return d.date;
          });
          keyText = vis.selectAll("text.key").data(data).enter().append("text").attr("class", "key").attr("y", function(d, i) {
            return height + 42 + 30 * (i % 3);
          }).attr("x", function(d, i) {
            return 155 * Math.floor(i / 3) + 15;
          }).attr("dx", x({
            x: .45
          })).attr("dy", ".71em").attr("text-anchor", "left").text(function(d, i) {
            return d[0].user;
          });
          keySwatches = vis.selectAll("rect.swatch").data(data).enter().append("rect").attr("class", "swatch").attr("width", 20).attr("height", 20).style("fill", function(d, i) {
            return color(i / (n - 1));
          }).attr("y", function(d, i) {
            return height + 36 + 30 * (i % 3);
          }).attr("x", function(d, i) {
            return 155 * Math.floor(i / 3);
          });
          scope.grouped = false;
          return scope.$watch("grouped", function(newVal, oldVal) {
            if (newVal === oldVal) {
              return;
            }
            if (newVal) {
              return transitionGroup();
            } else {
              return transitionStack();
            }
          });
        });
      }
    };
  });

}).call(this);
